text = """
x00: 1
x01: 0
x02: 1
x03: 1
x04: 0
x05: 0
x06: 1
x07: 1
x08: 0
x09: 1
x10: 1
x11: 1
x12: 1
x13: 1
x14: 0
x15: 1
x16: 0
x17: 1
x18: 0
x19: 0
x20: 0
x21: 1
x22: 0
x23: 1
x24: 1
x25: 0
x26: 0
x27: 0
x28: 1
x29: 1
x30: 0
x31: 1
x32: 0
x33: 0
x34: 0
x35: 1
x36: 0
x37: 0
x38: 1
x39: 1
x40: 0
x41: 1
x42: 0
x43: 1
x44: 1
y00: 1
y01: 0
y02: 0
y03: 1
y04: 1
y05: 0
y06: 0
y07: 0
y08: 0
y09: 0
y10: 0
y11: 1
y12: 0
y13: 0
y14: 0
y15: 0
y16: 1
y17: 0
y18: 0
y19: 0
y20: 1
y21: 0
y22: 0
y23: 1
y24: 0
y25: 0
y26: 0
y27: 0
y28: 0
y29: 0
y30: 1
y31: 0
y32: 1
y33: 1
y34: 0
y35: 1
y36: 0
y37: 0
y38: 0
y39: 1
y40: 0
y41: 0
y42: 1
y43: 0
y44: 1

ndk AND jfg -> krw
y15 XOR x15 -> kfw
mtq OR vkp -> kht
wmr XOR jkp -> z42
x14 XOR y14 -> jqt
ggr XOR hnd -> kwb
y05 XOR x05 -> mrn
x13 XOR y13 -> fgp
psd OR vcd -> bwt
cqv AND bfb -> jbr
x08 XOR y08 -> hmd
sps AND hfh -> bnk
htg OR gjq -> rwq
ktt OR kmd -> wmg
jks OR spt -> kgr
y27 XOR x27 -> cbw
npq OR qvc -> ptp
y04 XOR x04 -> pdw
x24 XOR y24 -> stj
y41 AND x41 -> gkt
cgn OR nkh -> gkw
vkh AND csn -> nnv
y21 AND x21 -> spq
gtb AND tdh -> svv
x09 AND y09 -> tfv
hjn OR hps -> sps
msg AND hdq -> hkg
hmd AND kgr -> vmq
crg XOR tms -> z38
x16 AND y16 -> hfq
x08 AND y08 -> mbt
dbm XOR pdw -> z04
ndk XOR jfg -> z43
bfb XOR cqv -> z09
wss XOR qrr -> z40
wmg AND jqt -> pjp
nnv OR pvp -> wvg
mmw AND knv -> gdq
vcp OR pgp -> gbv
x32 AND y32 -> wjn
mrn XOR hwr -> z05
y20 XOR x20 -> cdc
y31 AND x31 -> nmr
fgp XOR vjq -> z13
gbv XOR vms -> z26
y37 AND x37 -> wbc
x29 AND y29 -> jqn
y28 XOR x28 -> dsh
wvp OR bqt -> fbc
x19 XOR y19 -> csn
vhm OR wwd -> z24
fgp AND vjq -> kmd
wtv OR rtt -> hwr
x23 AND y23 -> pqw
vgf AND qkt -> psd
y10 AND x10 -> vcd
jkp AND wmr -> jdg
x30 XOR y30 -> fvm
prf AND dvr -> npq
x07 AND y07 -> jks
y04 AND x04 -> wtv
dmq AND fbc -> cks
x06 XOR y06 -> jvh
fvm AND psc -> hpm
crj AND kfw -> cgn
svv OR vpp -> prf
x00 XOR y00 -> z00
nss OR hst -> bdv
qts OR qfk -> mhr
cqs AND twk -> bqt
y42 AND x42 -> wjj
x39 XOR y39 -> mmw
nmr OR sbm -> bcd
x19 AND y19 -> pvp
x15 AND y15 -> nkh
dsh XOR wws -> z28
tcb AND ptp -> fcs
y26 AND x26 -> nss
y38 AND x38 -> vmm
pjr OR hkg -> dnp
ffr OR cph -> psc
qkf OR hfq -> cqs
x34 XOR y34 -> khr
vkh XOR csn -> z19
cvn AND hqj -> gmn
y17 XOR x17 -> twk
gkt OR pbd -> jkp
x29 XOR y29 -> cph
hfh XOR sps -> z23
jrh OR gmn -> gct
x18 XOR y18 -> dmq
y01 XOR x01 -> tdh
x16 XOR y16 -> cmc
vpb OR nnd -> bss
gct AND vjj -> jkc
fbc XOR dmq -> z18
khr AND dnp -> rsn
wvg XOR cdc -> z20
ggr AND hnd -> knh
kwb OR knh -> vjq
y35 AND x35 -> jrh
djq OR pjp -> crj
wqq AND gkk -> sbm
y05 AND x05 -> vpb
y23 XOR x23 -> hfh
rwq XOR jqn -> z29
y21 XOR x21 -> wpp
y40 AND x40 -> mtq
x33 AND y33 -> pjr
nvv AND bcd -> pgh
y17 AND x17 -> wvp
y03 XOR x03 -> tcb
gkw XOR cmc -> qkf
x28 AND y28 -> htg
vtm OR jkc -> ptr
cvn XOR hqj -> z35
y13 AND x13 -> ktt
hmn OR hcv -> hnd
kht XOR sdc -> z41
y32 XOR x32 -> nvv
x10 XOR y10 -> vgf
tcb XOR ptp -> z03
kgr XOR hmd -> z08
sbc OR cks -> vkh
x22 AND y22 -> hps
skh XOR tgr -> z25
x02 XOR y02 -> dvr
rfn OR fcs -> dbm
fkr OR hpm -> gkk
prf XOR dvr -> z02
wjn OR pgh -> hdq
x25 XOR y25 -> skh
x12 XOR y12 -> ggr
wws AND dsh -> gjq
vms AND gbv -> hst
qwb OR rsn -> cvn
y41 XOR x41 -> sdc
ksj OR krw -> mhv
twq AND wpp -> bvg
x30 AND y30 -> fkr
gkk XOR wqq -> z31
wpp XOR twq -> z21
crg AND tms -> hrr
x18 AND y18 -> sbc
vmm OR hrr -> knv
knv XOR mmw -> z39
jvh AND bss -> qts
wmg XOR jqt -> z14
jvh XOR bss -> z06
tdh XOR gtb -> z01
y11 XOR x11 -> gpc
y35 XOR x35 -> hqj
y34 AND x34 -> qwb
x24 AND y24 -> wwd
x43 XOR y43 -> ndk
bwt XOR gpc -> z11
cbw XOR bdv -> z27
cqs XOR twk -> z17
y38 XOR x38 -> tms
y42 XOR x42 -> wmr
wkb XOR mhv -> z44
x40 XOR y40 -> wss
kfc AND mpc -> hjn
x12 AND y12 -> z12
x11 AND y11 -> hmn
y25 AND x25 -> pgp
cbw AND bdv -> gmc
ptr AND cpq -> phk
ttg AND stj -> vhm
wss AND qrr -> vkp
qkt XOR vgf -> z10
x44 XOR y44 -> wkb
x06 AND y06 -> qfk
jqn AND rwq -> ffr
msg XOR hdq -> z33
gmc OR tnc -> wws
gpc AND bwt -> hcv
mhr XOR qbw -> z07
fvm XOR psc -> z30
ptr XOR cpq -> z37
x33 XOR y33 -> msg
x09 XOR y09 -> bfb
spq OR bvg -> kfc
kfw XOR crj -> z15
pdw AND dbm -> rtt
mrn AND hwr -> nnd
y27 AND x27 -> tnc
x14 AND y14 -> djq
x00 AND y00 -> gtb
wbc OR phk -> crg
wvg AND cdc -> qwk
gct XOR vjj -> z36
x02 AND y02 -> qvc
bcd XOR nvv -> z32
x26 XOR y26 -> vms
gkw AND cmc -> z16
khr XOR dnp -> z34
y20 AND x20 -> nfd
ttg XOR stj -> tgr
y36 XOR x36 -> vjj
y39 AND x39 -> vvb
y03 AND x03 -> rfn
y36 AND x36 -> vtm
qbw AND mhr -> spt
mbt OR vmq -> cqv
wkb AND mhv -> hsh
mpc XOR kfc -> z22
wjj OR jdg -> jfg
bnk OR pqw -> ttg
x07 XOR y07 -> qbw
x43 AND y43 -> ksj
sdc AND kht -> pbd
x01 AND y01 -> vpp
y22 XOR x22 -> mpc
jbr OR tfv -> qkt
hsh OR vww -> z45
gdq OR vvb -> qrr
x31 XOR y31 -> wqq
skh AND tgr -> vcp
x37 XOR y37 -> cpq
y44 AND x44 -> vww
qwk OR nfd -> twq
"""

text_test = """
x00: 1
x01: 1
x02: 1
y00: 0
y01: 1
y02: 0

x00 AND y00 -> z00
x01 XOR y01 -> z01
x02 OR y02 -> z02
"""

text_test2 = """
x00: 1
x01: 0
x02: 1
x03: 1
x04: 0
y00: 1
y01: 1
y02: 1
y03: 1
y04: 1

ntg XOR fgs -> mjb
y02 OR x01 -> tnw
kwq OR kpj -> z05
x00 OR x03 -> fst
tgd XOR rvg -> z01
vdt OR tnw -> bfw
bfw AND frj -> z10
ffh OR nrd -> bqk
y00 AND y03 -> djm
y03 OR y00 -> psh
bqk OR frj -> z08
tnw OR fst -> frj
gnj AND tgd -> z11
bfw XOR mjb -> z00
x03 OR x00 -> vdt
gnj AND wpb -> z02
x04 AND y00 -> kjc
djm OR pbm -> qhw
nrd AND vdt -> hwm
kjc AND fst -> rvg
y04 OR y02 -> fgs
y01 AND x02 -> pbm
ntg OR kjc -> kwq
psh XOR fgs -> tgd
qhw XOR tgd -> z09
pbm OR djm -> kpj
x03 XOR y03 -> ffh
x00 XOR y04 -> ntg
bfw OR bqk -> z06
nrd XOR fgs -> wpb
frj XOR qhw -> z04
bqk OR frj -> z07
y03 OR x01 -> nrd
hwm AND bqk -> z03
tgd XOR rvg -> z12
tnw OR pbm -> gnj
"""


def read_input(text):
    inp = dict()
    gates = []
    final = set()
    for line in text.split('\n'):
        if not line:
            continue

        if ':' in line:
            k,v = line.split(': ')
            inp[k] = int(v)

        else:
            exp, res = line.split(' -> ')
            gates.append([*exp.split(), res])
            if 'z' in res:
                final.add(res)

    return inp, gates, final


print(read_input(text_test))

def try_calc(gate, inp):
    a, op, b, r = gate
    if a not in inp or b not in inp or r in inp:
        return
    
    if op == 'AND':
        inp[r] = inp[a] and inp[b]
    elif op == 'OR':
        inp[r] = inp[a] or inp[b]
    elif op == 'XOR':
        inp[r] = inp[a] ^ inp[b]

    return



def solve(text):
    inp, gates, final = read_input(text)

    prev = 0
    while len(prev) != len(inp) and len(set(inp.keys()) & final) < len(final):
        print(prev, len(inp))
        prev = len(inp)
        for gate in gates:
            try_calc(gate, inp)

    if len(set(inp.keys()) & final) < len(final):
        return None
    

    res = [-1] * len(final)
    for k in final:
        ind = int(k[1:])
        res[ind] = inp[k]
    
    res_int = 0
    for i in range(len(res)-1, -1, -1):
        r = res[i]
        res_int *= 2
        res_int += r
    return res_int

    

# print(solve(text))

def calc(gates, inp):
    for gate in gates:
        try_calc(gate, inp)

def calc_int(gates, inp, final):

    prev = 0
    while prev != len(inp) and len(set(inp.keys()) & final) < len(final):
        # print(prev, len(inp))
        prev = len(inp)
        calc(gates, inp)

    if len(set(inp.keys()) & final) < len(final):
        return None
        

    res = [-1] * len(final)
    for k in final:
        ind = int(k[1:])
        res[ind] = inp[k]
    
    res_int = 0
    for i in range(len(res)-1, -1, -1):
        r = res[i]
        res_int *= 2
        res_int += r
    return res_int

def get_inp_from_int(a, ch, bits, m):
    for i in range(bits):
        k = ch
        if i < 10:
            k += '0'
        k += str(i)
        m[k] = int((a & (1 << i)) > 0)

def get_inp_from_ints(a,b, bits):
    m = dict()
    get_inp_from_int(a,'x',bits, m)
    get_inp_from_int(b,'y',bits, m)
    return m


import random
def gen_tests(bits):
    # while True:
    #     yield random.randrange(0, (1 << (bits+1))-1), random.randrange(0, (1 << (bits+1))-1)
    yield 0,0
    for i in range(bits-1, -1, -1):
        yield 1 << i, 0
        yield 0, 1 << i
        yield 1 << i, 1 << i
    for i in range(bits-2, -1, -1):
        yield (1 << i) + (1 << (i+1)), 1 << i
        yield 1 << i, (1 << i) + (1 << (i+1))

def test_suite(a,b,bits,gates, final):
    failed = set()
    for i, (a,b) in enumerate(gen_tests(bits)):

        m = get_inp_from_ints(a, b, bits)
        r = calc_int(gates, m, final)
        if a + b != r:
            failed.add(i)

    return failed


def print_res(res):
    r = []
    for a,b in res:
        r.append(a)
        r.append(b)
    return ','.join(sorted(r))

def solve2(text):
    inp, gates, final = read_input(text)

    # generate small tests
    bits = len(inp) // 2
    res = []
    for a,b in gen_tests(bits):
        m = get_inp_from_ints(a, b, bits)
        #print("a = {}, b = {}, inp = {}, final = {}".format(a,b,m, final))
        r = calc_int(gates, m, final)
        if a+b != r:
            print("expected {} + {} = {}, got {}".format(a,b,a+b, r))

            # try find pair of gates to swap
            successes = []
            for i, gate1 in enumerate(gates):
                # print("checking gate # {}: {}".format(i, gate1))
                for j, gate2 in enumerate(gates[:i]):
                    # print("trying swap {} with {}".format(gate1, gate2))
                    r1, r2 = gate1[3], gate2[3]
                    gate1[3], gate2[3] = r2, r1
                    # print("swapped: {} and {}".format(gate1, gate2))


                    m = get_inp_from_ints(a, b, bits)
                    r = calc_int(gates, m, final)
                    if a + b == r:
                        successes.append((i,j))

                    gate1[3], gate2[3] = r1,r2
            
            if len(successes) == 1:
                i,j = successes[0]
                print("fonud single swap: {} <=> {}".format(gates[i][3], gates[j][3]))
                r1, r2 = gates[i][3], gates[j][3]
                gates[i][3], gates[j][3] = r2, r1
                res.append((gates[i][3], gates[j][3]))
                if len(res) == 4:
                    return print_res(res)
            else:
                print("failed to find single swap:", successes)

                # search for a pair that strictly decreases number of failed tests
                failed_before = test_suite(a,b,bits, gates, final)

                strict_successes = []
                for i,j in successes:
                    r1, r2 = gates[i][3], gates[j][3]
                    gates[i][3], gates[j][3] = r2, r1
                    failed_after = test_suite(a,b,bits, gates, final)
                    r1, r2 = gates[i][3], gates[j][3]
                    gates[i][3], gates[j][3] = r2, r1


                    if len(failed_after) < len(failed_before) and len(failed_before | failed_after) == len(failed_before):
                        print("strictly better {}, {}, fixed cases: {}, after: {}".format( i,j, failed_before - failed_after, failed_after))
                        strict_successes.append((i,j, len(failed_after)))

                        if len(failed_after) == 0:
                            print("apply last single swap: {} <=> {}".format(gates[i][3], gates[j][3]))
                            r1, r2 = gates[i][3], gates[j][3]
                            gates[i][3], gates[j][3] = r2, r1
                            res.append((gates[i][3], gates[j][3]))
                            if len(failed_after) == 0:
                                return print_res(res)

                if len(strict_successes) == 1:
                    i,j, _ = strict_successes[0]
                    print("apply single swap: {} <=> {}".format(gates[i][3], gates[j][3]))
                    r1, r2 = gates[i][3], gates[j][3]
                    gates[i][3], gates[j][3] = r2, r1
                    res.append((gates[i][3], gates[j][3]))
                    # if len(res) == 4:
                    #     return res
                    if len(failed_after) == 0:
                        return print_res(res)
                elif strict_successes:
                    strict_successes.sort(key=lambda x: x[2])
                    i,j, _ = strict_successes[0]
                    print("apply single swap: {} <=> {}".format(gates[i][3], gates[j][3]))
                    r1, r2 = gates[i][3], gates[j][3]
                    gates[i][3], gates[j][3] = r2, r1
                    res.append((gates[i][3], gates[j][3]))
                    # if len(res) == 4:
                    #     return res
                    if len(failed_after) == 0:
                        return print_res(res)

        else:
            print("success {} + {} = {}".format(a,b,a+b))
        

    


print(solve2(text))